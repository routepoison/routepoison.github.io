# Linux Services & Internals Enumeration

Now that we've dug into the environment and gotten the lay of the land and uncovered as much as possible about our user and group permissions as they relate to files, scripts, binaries, directories.

Here are some of the questions we'd like the know the answers to:

* What services and applications are installed?
* what services are running?
* what sockets are in use?
* what users, admins, and groups exist on the system?
* who is currently logged in? what users recently logged in?
* what password policies, if any, are enforced on the host?
* is the host joined to an Active Directory domain
* what types of interesting information can we find in history, log, and backup files
* which files have been modified recently and how often? are there any interesting patterns in file modification that could indicate a cron job in use that we may be able to hijack
* current IP address information
* anything interesting in the **/etc/hosts** file?
* are there any interesting network connections to other systems in the internal network or even outside network
* what tools are installed on the system that we may be able to take advantage of? (Netcat, Perl, Python, Ruby, Nmap, tcpdump, gcc, etc)
* can we access the `bash_history` file for any users and can we uncover anything interesting from their recorded comman line history such as passwords?

`ip a`

`cat /etc/hosts`

It can also be helpful to check out each user's last login time to try to see when users typically log in to the system and how frequently. This can give us an idea of how widely used this system is which can open up the potential for more misconfigurations or "messy" directories or command history

`lastlog`

In addition, let's see if anyone else is currently on the system with us. There are a few ways to do this, such as `who` and `finger` on some linux system

## Finding History Files

`find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null`

It's also a good idea to check for cron jobs. In conjunction with other misconfigurations such as relative paths or weak permission, they can leverage to escalate privileges when the scheduled cron job runs.

## Cron

`ls -la /etc/cron.daily/`

## Proc

The [proc filesystem](https://man7.org/linux/man-pages/man5/proc.5.html) (`proc` / `procfs`) is a particular filesystem in Linux that contains information about system processes, hardware, and other system information. It is the primary way to access process information and can be used to view and modify kernel settings. It is virtual and does not exist as a real filesytem but is dynamically generated by the kernel. It can be use to look up system information such as state of running processes, kernel paramters, system memory, and devices. It also sets certain system parameters, such as process priority, scheduling, and memory allocation.

`find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n"`

## Services

If it is a slightly older linux system, the liklihood increases that we can find installed packages that may have  at least one vulnerability. However, current versions of Linux distributions can also have older packages or software installed that may have such vulnerabilities. Therefore, we will see a method to help us detect potentially dangerous packages in a bit. To do this, we first need to create a list of installed packages to work with:

### Installed Packages

`apt list --installed | tr "/" " " | cut -d" " -f1,3 | sed 's/[0-9]://g' | tee -a installed_pkgs.list` 

## Sudo Version

`sudo -V`

Occasionally it can also happen that no direct packages are installed on the system but compiled programs in the form of binaries. These do not require installation and can be executed by the system itself

## Binaries

`ls -l /bin /usr/bin/ /usr/sbin/`

[GTFObins](https://gtfobins.github.io/) provides an excellent platform that includes a list of binaries that can potentially be exploited to escalate our privileges on the target system. With the next oneliner, we can compare the existing binaries from the ones from GTFObins to see which binaries we should investigate later

`for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | sed '/^[[:space:]]*$/d'); do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for $i";fi;done`

We can use diagnostic tool `strace` on Linux-based operating systems to track and analyze system calls and signal processing. It allows us to follow the flow of a program and understand how it accesses system resources, process signals, and receives and sends data from the operating system. In additiona, we can also use the tool to monitor security-related activities and identify potential attack vectors, such as specific request to remote hosts using passwords for tokens

The output of `strace` can be written to a file for later analysis, and it provides a wealth of options that allow detailed monitoring of the programs behavior:

`strace ping -c1 10.129.112.20`

Users can read almost all configuration files on a Linux OS if the admin has kept them the same. These config files can often reveal how the service is setup and configured to understand better how we can use it for our purposes. In addition, these files can contain sensitive information, such as keys and paths to files in folders that we cannot see. However, if the file has read permissions for everyone, we can still read the file even if we do not have permission to read the folder.

`find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null`

The scripts are similar to config files. Often Admins are lazy and convinced of network security and neglect the internal security of their systems. These scripts, in some cases, have such wrong privileges that we will deal with later, but the contents are of great importance even without these privileges. Because through them, we can discover internal and individual processes that can be of great use to us.

`find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share"`

Also, if we look at the process list, it can give us info about which script or binary are in use and by which user. For example, if it is a script created by the admin in his path and whose rights have not been restrictred, we can run it without going into the root directory.

## Running Services by User

`ps aux | grep root`

This would give us a good overview of our target system.

---

↩️: [Home](../../index.md)
